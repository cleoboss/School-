CMP 407 EXAM PREP
Best Practice: Study using a big screen devic   e. Be it a laptop or a tablet. It won't be best to use phones (even though y'all ain't with your phones ðŸ˜‰)



----------------------------------------------------------------



Module 1

1a. What is a Compiler?
ans: A compiler is a program that can read a program in one language(the source language) and 
translate it into an equivalent program in another language (the target language)

b. An important role of the compiler is to report any errors in the source program that it detects during the translation process. true or false?
ans: true

c. Draw a diagram of the compiler?
ans: Slide(page 1)

d. List the 6 phases of a compiler?
ans: 1. Lexical Analysis 
     2. Syntax Analysis 
     3. Semantic Analysis 
     4. Intermediate Code Generation 
     5. Code Optimization 
     6. Target Code Generation

e. Draw a diagram of the Phases of Compiler?
ans: Slide(page 2)


Lexical Analysis 
f. ___________ is the first phase of a compiler?
ans: Lexical Analysis (or scanning)

g. What does the Lexical Analyzer do?
ans: it reads the stream of characters making up the source program and groups the characters into meaningful sequences called lexemes

h. For each lexeme, the lexical analyzer produces an output token of the form __________________?
ans: <token- name, attribute-value>

h1. It is this token that the lexical analyzer then pass on to the subsequent phase. true or false?
ans: true

h2. In the token, the first component token- name is _____________________?
ans: an abstract symbol that is used during syntax analysis

h3. The second component attribute-value points to _____________________?
ans: an entry in the symbol table (for this token)

i. Information from the symbol-table entry is needed for _____________ and ____________ ?
ans: semantic analysis and code generation

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

MAIN EXAMPLE:

For example, suppose a source program contains the assignment statement 

position = initial + rate * 60

The characters in this assignment could be grouped into the following lexemes and mapped 
into the following tokens passed on to the syntax analyzer: 

1. `position` is a lexeme that would be mapped into a token <id, 1>, where id is an abstract 
symbol standing for identifier and 1 points to the symbol table entry for position. The 
symbol-table entry for an identifier holds information about the identifier, such as its name and type. 

2. The assignment symbol = is a lexeme that is mapped into the token < = >. Since this token 
needs no attribute-value, we have omitted the second component .  

3. `initial` is a lexeme that is mapped into the token < id, 2> , where 2 points to the symbol table 
entry for initial. 

4. + is a lexeme that is mapped into the token <+>. 

5. `rate` is a lexeme that is mapped into the token < id, 3 >, where 3 points to the symbol-table 
entry for rate. 

6. * is a lexeme that is mapped into the token <*> . 

7. 60 is a lexeme that is mapped into the token <60>  

Blanks separating the lexemes would be discarded by the lexical analyzer. The representation 
of the assignment statement  position = initial + rate * 60  after lexical analysis as the sequence of tokens as: 
   < id, l > < = > <id, 2> <+> <id, 3> < * > <60> Token Stream


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

j. Given the below assignment statement. Group the characters into there lexemes and map them to there following tokens

height = 10 + constant - initial / 55

ans: 1. height is a lexeme that would map to <id, 1> where 1 points to the symbol table entry for height  

     2. The assignment symbol = is a lexeme that would map to <=>  

     3. 10 is a lexeme that would map to <10>  

     4. + is a lexeme that would map to <+>  

     5. constant is a lexeme that would map to <id, 2> where 2 points to the symbol table entry for constant  

     6. - is a lexeme that would map to <->  

     7. initial is a lexeme that would map to <id, 3> where 3 points to the symbol table entry for initial  

     8. / is a lexeme that would map to </>  

     9. 55 is a lexeme that would map to <55>  

     The representation of the assignment statement would then be  

     <id, 1> <=> <10> <+> <id, 2> <-> <id, 3> </> <55>

Syntax Analysis
k. The second phase of the compiler is __________________
ans: syntax analysis (or parsing)

l. What does the Syntax Analyzer do?
ans: The Syntax Analyzer (or parser) uses the first components of the tokens produced by the lexical analyzer to create a tree-like intermediate representation that depicts the grammatical structure of the token stream

m. A typical representation is a syntax tree in which each interior node represents an operation and the children of the node represent the arguments of the operation. Show an example of this using the below lexemes from earlier

< id, l > < = > <id, 2> <+> <id, 3> < * > <60> Token Stream

ans: 
         =
       /   \
      /     \
<id, 1>      +
           /   \
          /     \
    <id, 2>      *
               /   \
              /     \       (Syntax Tree)
          <id, 3>    60

m1. The tree above has an interior node labeled with ( id, 3 ) as its left child and the integer 60 as its right child. The node (id, 3) represents the identifier rate. The node labeled * makes it explicit that we must first multiply the value of rate by 60. The node labeled + indicates that we must add the result of this multiplication to the value of init ial. The root of the tree, labeled =, indicates that we must store the result of this addition into the location for the identifier position. true or false?
ans: true


Semantic Analysis
n. The Semantic Analyzer uses the syntax tree and the information in the symbol table to __________________________________
ans: check the source program for semantic consistency with the language definition

o. Semantic Analyzer also gathers type information and saves it in either ______________ or _____________, for subsequent use during intermediate-code generation
ans: the syntax tree, the symbol table

p. Semantic Analyzer gathers type information to use during ____________________?
ans: intermediate-code generation

q. An important part of semantic analysis is type checking, where ______________________________
ans: the compiler checks that each operator has matching operands

q1. Give an example of such a scenario. 
ans: For example, many programming language definitions require an array index to be an integer; the 
     compiler must report an error if a floating-point number is used to index an array

r. Some sort of type conversion is also done by the semantic analyzer. true or false?
ans: true

r1. if an operator is applied to a floating point number and an integer, the compiler may convert the 
integer into a floating point number. true or false?
ans: true

r2. In our example `position = initial + rate * 60`, suppose that position, initial, and rate have 
been declared to be floating-point  numbers,  and  that  the  lexeme  60  by  itself  forms  an  integer. The semantic  analyzer  discovers that the operator * is applied to a floating-point number rate and an integer 60. In this case, the integer may be converted into a floating-point number. true or false?
ans: true

r3. if rate where a floating-point number, how would our syntax tree look?
ans:   
         =
       /   \
      /     \
<id, 1>      +
           /   \
          /     \
    <id, 2>      *
               /   \
              /     \       (Syntax Tree)
        <id, 3>  inttofloat
                     |         
                     60


Intermediate Code Generation
s. In the process of translating a source program into target code, a compiler may construct one 
or more intermediate representations, which can have a variety of forms. Syntax trees are a 
form of intermediate representation; they are commonly used during syntax and semantic analysis.
ans: true

t. After syntax and semantic analysis of the source program, many compilers generate an explicit low-level 
   or machine-like intermediate representation, which we can think of as a program for an abstract machine. true or false
ans: true

u. Intermediate code representations should have 2 important properties. Name them?
ans: 1. It should be simple and easy to produce   
     2. It should be easy to translate into the target machine

Using the `position = initial + rate * 60` example (if rate was a floating-point value)
v. What would the intermediate representation of our assignment statement be?
ans: t1 = inttofloat(60)
     t2 = id3 * t1
     t3 = id2 + t2
     id1 = t3


Code Optimization
w. Explain this phase?
ans: The machine-independent code-optimization phase attempts to improve the intermediate code 
so that better target code will result. The objectives for performing optimization are: faster 
execution, shorter code, or target code that consumes less power. In our example, the optimized 
code is

x. What would the optimized code look like?
ans: t1 = id3 * 60.0
    id1 = id2 + t1


Code Generation
y. Explain this phase?
ans: The code generator takes as input an intermediate representation of the source program and 
maps it into the target language. If the target language is machine code, registers or memory 
locations  are  selected  for  each  of  the  variables  used  by  the  program.  Then,  the 
intermediate  instructions  are  translated  into  sequences  of  machine  instructions  that 
perform the same task. A crucial aspect of code generation is the judicious assignment of 
registers to hold variables. 

















